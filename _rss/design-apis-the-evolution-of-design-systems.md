---
title: "Design APIs - the evolution of design systems"
date: 2021-03-11 13:47:36 +0000
dateadded: 2021-03-11 13:47:36 +0000
description: ""
link: "https://matthewstrom.com/writing/design-apis/"
category:
directory:
- _directory/matthew-ström.md
---
<figure data-type="image"><img src="https://matthewstrom.com/images/design-apis-02.jpg" alt=""></figure>
<p>Design systems enable designers and developers to quickly create quality software on a massive scale. As the needs of software-driven businesses grow even larger, design systems are evolving — they are beginning to look and work like APIs.</p>
<p>In software development, “API” stands for “Application Programming Interface.” An API is a reliable way for two or more programs to cooperate. It allows programs to work together despite differences in hardware, language, architecture, or other operating constraints.</p>
<p>APIs power the internet. They are so powerful because they embody a contract: system A promises to act in a predictable way, as long as system B requests that action in an agreed-upon way. Say system A is PayPal and system B is Etsy: PayPal promises to make a transaction between two bank accounts (a buyer’s and a seller’s), as long as Etsy requests that transaction formatted in a secure and trustworthy way with permission from its users.</p>
<p>As long as these contracts are in place, Etsy and PayPal can write and re-write their own systems without needing to check in with each other. They can work independently and efficiently, according to their own needs. A reliable API creates trust and drives cooperation.</p>
<p>The API model is the perfect match for communication between designers and developers.</p>
<nav class="table-of-contents"><ol><li><a href="#a-pseudo-api">A Pseudo-API</a></li><li><a href="#design-systems">Design Systems</a></li><li><a href="#the-problem-with-design-systems-as-apis">The Problem with Design Systems as APIs</a></li><li><a href="#abstracting-a-design-system-into-a-design-api">Abstracting a Design System Into a Design API</a><ol><li><a href="#rules-for-making-requests">Rules for Making Requests</a></li><li><a href="#an-endpoint">An Endpoint</a></li><li><a href="#example-requests">Example Requests</a></li><li><a href="#example-responses">Example Responses</a></li><li><a href="#errors">Errors</a></li><li><a href="#putting-it-all-together">Putting It All Together</a></li></ol></li><li><a href="#the-current-state-of-design-apis">The Current State of Design APIs</a><ol><li><a href="#design-tokens">Design Tokens</a></li><li><a href="#standard-formats">Standard Formats</a></li></ol></li><li><a href="#the-future-of-design-apis">The Future of Design APIs</a></li><li><a href="#conclusion">Conclusion</a></li></ol></nav><h2 id="a-pseudo-api">A Pseudo-API</h2>
<p>If you’re a designer or developer, there’s already an API layer between you and your counterparts. That API might not be well-documented or consistent, but it forms the basis for your communication with each other.</p>
<p>For instance, at Bitly (where I work), designers provide information about design decisions in the form of Sketch files in a tool called Abstract. We’re working with engineers to make sure the format works for everyone as an efficient and accurate way to share specifications.</p>
<p>These standards and informal working agreements look a lot like the beginnings of an API. But our documentation  isn’t like a typical API’s documentation (for an example of a well-documented API, see <a href="https://stripe.com/docs/api" target="_blank" rel="noopener">Stripe’s API reference</a>). The design team hasn’t listed any endpoints. There are no sample requests to learn from, or expected return values to test against. Our pseudo-API doesn’t have an uptime guarantee, a service-level agreement, or rate limits. It also doesn’t fail very gracefully. When something goes wrong, no errors are thrown, and nobody’s pager goes off.</p>
<p>A small team can work through this uncertainty without losing much productivity. But as a team grows, it needs a clearer contract between designers and developers.</p>
<h2 id="design-systems">Design Systems</h2>
<p>Design systems have become an essential tool for fast-paced application development teams. A good design system provides some of the documentation developers need in order to get information about what they are building. Like an API, a design system is an abstraction. An API abstracts some of a program’s functionality; a design system abstracts some of the design process.</p>
<p>Companies like Salesforce have led the way in implementing large-scale design systems. Salesforce has thousands of developers and designers working on features across many platforms and applications. To enable this kind of work at scale, the team collaborated to produce a design system called <a href="https://lightningdesignsystem.com/" target="_blank" rel="noopener">Lightning</a>.</p>
<p>Lightning is a contract. On one side, it outlines very specific ways for developers to mark up their code to ensure the user experience is delivered consistently. For instance, a developer agrees that they’ll use a specific style of markup:</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>slds-button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code></pre>
<p>In return, Lightning guarantees that this button will have the proper appearance and functionality. It will meet Salesforce’s standards of usability and accessibility.</p>
<p>On the other side of the contract, Lightning specifies rules for creating or modifying design specifications. For instance, a designer agrees to follow guidelines for using toggle switches in forms:</p>
<figure data-type="image"><img src="https://matthewstrom.com/images/design-apis-01.png" alt=""></figure>
<p>In return, Lightning promises that these design decisions will be delivered quickly to end users with fidelity and integrity. The application will continue to meet Salesforce’s standards of performance and reliability.</p>
<h2 id="the-problem-with-design-systems-as-apis">The Problem with Design Systems as APIs</h2>
<p>Lightning works for Salesforce, but it requires a dedicated team of engineers and designers. The design system team is solely responsible for Lightning’s continued performance: they maintain the documentation, educate users, evangelize for adoption across the organization, and monitor how the system is working.</p>
<p>A dedicated design system team is required because a design system is only a low-level abstraction of the design process.</p>
<p>This means the design system’s documentation — the website or wiki or design file that describes it — is its most useful application. For instance, the easiest way to use the colors Lightning provides is to visit <a href="https://www.lightningdesignsystem.com/design-tokens/#category-color" target="_blank" rel="noopener">the ‘Colors’ page on Lightning’s website</a>.</p>
<p>Think of this like a phone book. A phone book is a low-level abstraction of a phone number directory. To find someone’s number, you flip through the pages of the phone book until you find their name. A whole team of people produces the phone book, printing and distributing it on a regular basis to ensure it is up to date.</p>
<p>Adding one level of abstraction to a phone directory means removing the printed book from the equation. Instead of flipping through pages, a user types a name into a search box and instantly sees that person’s phone number. The number can be kept up to date without reprinting a hefty book. Other programs can read this information, too: Integrations to messaging apps might mean the end user never needs to see the phone number at all.</p>
<h2 id="abstracting-a-design-system-into-a-design-api">Abstracting a Design System Into a Design API</h2>
<p>What does a design API look like? Taking cues from other software APIs, a design API has four ingredients:</p>
<ol>
<li>Rules for making requests</li>
<li>A URL called an endpoint that serves as the address for incoming requests</li>
<li>A clear definition of what a properly formatted request looks like</li>
<li>A clear definition of what the API’s response will be under different circumstances</li>
</ol>
<h3 id="rules-for-making-requests">Rules for Making Requests</h3>
<p>There are many different protocols for APIs on the web, like SOAP and REST. Each protocol defines rules for how requests can be made. REST, for instance, defines the “verbs” that a request can include: “POST” adds new data, while “GET” reads existing data. Likewise, our design API needs rules to ensure a user can interact with it in predictable ways.</p>
<p>Additionally, some APIs require users to tie their requests to a specific account. There are many different ways of authenticating requests, from simple password-like tokens to more complicated exchanges like OAuth. Authentication helps an API protect functionality from misuse, accidental or otherwise.</p>
<p>A design API needs rules around what kinds of requests can be made. Is it read only, or can a user update design information via the API, too? What kind of authorization is needed for each kind of request? Defining and providing these rules to users keeps the API running smoothly.</p>
<h3 id="an-endpoint">An Endpoint</h3>
<p>An endpoint is the URL used to make a request to an API. For example, to shorten a link with the Bitly API, you send a request to <code>https://api-ssl.bitly.com/v4/shorten</code>.
Our design API might have an endpoint for system colors, like <code>https://example.com/api/colors</code>. Or an endpoint for a dropdown component: <code>.../components/dropdown</code>.</p>
<h3 id="example-requests">Example Requests</h3>
<p>The most basic request in an API is to simply request to see the information provided by an endpoint. For example, a design API might treat <code>GET https://example.com/api/colors</code> as a complete request, and respond with a list of colors.</p>
<p>More complicated requests involve extra information in the form of what are called query parameters. Query parameters get added to an endpoint’s URL and provide data to the API. An example of a query parameter is <code>?v=uwprhJZHd5Y</code> at the end of <code>https://www.youtube.com/watch?v=uwprhJZHd5Y</code>: the string of letters and numbers tells YouTube which video you’d like to watch.</p>
<p>An example request with query parameters solves a common use case: a web developer needs colors in hex format — <code>#ffffff</code> — while an iOS developer needs them to be formatted as a UIColor — <code>[UIColor colorWithRed:1.00 green:1.00 blue:1.00 alpha:1.0];</code>. Our design API could respond to the requests <code>GET https://example.com/api/colors?format=hex</code> and <code>GET https://example.com/api/colors?format=uicolor</code> with only the correctly-formatted colors.</p>
<h3 id="example-responses">Example Responses</h3>
<p>Example requests give users guidelines for interacting with the API. But that’s only half of the equation: the API needs to talk back.</p>
<p>Consistent and well-structured responses are vital to effective APIs. For instance, if <code>GET .../colors</code> results in a list of hex values, you wouldn’t expect <code>GET .../colors/blue</code> to result in RGB values.</p>
<p>An example response for the <code>GET https://example.com/api/colors</code> action might look like this:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>		<span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"blue"</span><span class="token punctuation">,</span><br>		<span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"#0000ff"</span><br>	<span class="token punctuation">}</span><span class="token punctuation">,</span><br>	<span class="token punctuation">{</span>...<span class="token punctuation">}</span><br><span class="token punctuation">]</span></code></pre>
<p>Providing this example tells a user to expect the color to be provided in hexadecimal format, along with each color’s name. A developer could use this template to write their own application, knowing that the API will always provide the information in this format.</p>
<h3 id="errors">Errors</h3>
<p>An important but often-overlooked feature of an API is error handling. If a request to the API doesn’t result in the desired action, the API should respond with some information on what went wrong. Some common errors are:</p>
<ul>
<li><strong>Not found:</strong> sent when the request was valid, but there’s nothing available at the specified endpoint.</li>
<li><strong>Server error:</strong> sent when something is wrong with the API itself.</li>
<li><strong>Authentication error:</strong> sent when authentication is required but wasn’t present in the request.</li>
<li><strong>Invalid request:</strong> sent when the user’s request wasn’t correctly formatted.</li>
</ul>
<p>Good error handling in a design API would help the software on the other end know how to proceed. For example, sending the request <code>GET https://example.com/api/colors/fuchsia</code> might return a ’Not Found’ error if fuchsia isn’t a color in the system. The program that made the request might then try something more common, like <code>GET https://example.com/api/colors/purple</code>. If the original request resulted in a ‘Server Error’ instead, the requesting program might wait and try again later.</p>
<h3 id="putting-it-all-together">Putting It All Together</h3>
<p>Combining these components, we get an example of what an API for design might look like.</p>
<hr>
<p><strong>How to use the API</strong></p>
<p>Our API accepts form-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.</p>
<p><strong>Endpoint</strong></p>
<pre class="language-html"><code class="language-html">https://example.com/api/colors</code></pre>
<p><strong>Example request</strong></p>
<pre class="language-http"><code class="language-http">GET https://example.com/api/colors</code></pre>
<p><strong>Example response</strong></p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>		<span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"blue"</span><span class="token punctuation">,</span><br>		<span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">"#0000ff"</span><br>	<span class="token punctuation">}</span><span class="token punctuation">,</span><br>	<span class="token punctuation">{</span>...<span class="token punctuation">}</span><br><span class="token punctuation">]</span></code></pre>
<hr>
<p>This is a very simple example of how a design API would be able to provide design information to another program.</p>
<h2 id="the-current-state-of-design-apis">The Current State of Design APIs</h2>
<h3 id="design-tokens">Design Tokens</h3>
<p>Some design systems, like Lightning or Shopify’s <a href="https://polaris.shopify.com/" target="_blank" rel="noopener">Polaris</a>, have pioneered the use of design tokens. Design tokens are structured values in a machine-readable file, similar to the response you’d expect from a design API.</p>
<p>Salesforce’s <a href="https://github.com/salesforce-ux/theo" target="_blank" rel="noopener">Theo</a> and Amazon’s <a href="https://amzn.github.io/style-dictionary" target="_blank" rel="noopener">Style Dictionary</a> are leading the way for the creation and distribution of design tokens. Both perform the same basic function: given a single set of design decisions, they generate a wide array of formats suitable to be used directly in a platform or application.</p>
<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class="embed-container"><iframe src="https://www.youtube.com/embed/1HREvonfqhY" frameborder="0" allowfullscreen=""></iframe></div>
<p>I recently used Style Dictionary to build a set of design tokens for Bitly. Those tokens are then distributed via NPM, enabling Bitly developers to pull in the latest version of our design decisions without needing to dig into Sketch files or ask on Slack.
Design tokens are a huge step towards a fully developed design API. However, they are generated and distributed in bulk. If you only need one token, you need to import the whole library. That means they’re still a type of phone book, albeit one that is formatted in a way that software can easily read.</p>
<p>Also, design tokens are read-only. Updates to the original values require a completely different set of tools than downloading and using the tokens themselves. This division of labor requires more contributors, leading to the kinds of dedicated teams we see publishing and maintaining design systems today.</p>
<h3 id="standard-formats">Standard Formats</h3>
<p>Every design system has its own way of defining colors, font sizes, spacing, and type styles. For example, Google’s Material Design designates 14 shades of each color, using a numbered system to indicate how dark each shade is. Lightning, on the other hand, uses aliases like $brand-text-link or $color-background to denote how each color should be used.
In <a href="https://jxnblk.com/blog/interoperability/" target="_blank" rel="noopener">“Interoperability,&quot;</a> Brent Jackson describes how this makes software development — specifically, moving from Basscss to Tachyons, both of which are CSS libraries — more difficult:</p>
<blockquote>
<p>The real tragedy here in the divergent naming conventions is that if you’ve started building an application with Basscss, but then want to upgrade to something more fully-featured like Tachyons, you’ll have to do a lot of manual work to migrate. Essentially, HTML templates written with either of these libraries isn’t as portable as if we’d used a standard syntax, for example inline styles.</p>
</blockquote>
<p>Jackson goes on to suggest a <a href="https://styled-system.com/theme-specification/" target="_blank" rel="noopener">standard format</a> for colors, fonts, and sizes.</p>
<p>The emergence of standard formats means that applications can work seamlessly with multiple design systems or migrate from one to another with little effort. Standardization also makes it faster to build new systems. Having a comprehensive template for your design language all but eliminates one of the hardest problems in software development: <a href="https://twitter.com/codinghorror/status/506010907021828096?s=20" target="_blank" rel="noopener">naming</a>.</p>
<p>But an API also reduces the importance of a consistent naming scheme. A well-documented and machine-readable format for design data can be easily transformed into whichever format your application requires.</p>
<h2 id="the-future-of-design-apis">The Future of Design APIs</h2>
<p>The increasing popularity of design tokens and the drive towards a standard format for design systems mean that design APIs are just around the corner. These rich APIs will enable what I call <strong>networked design systems</strong>.</p>
<p>Networked design systems are sets of applications and tools that are capable of communicating with each other about design decisions. Contrast this with the state of the art: the closest we come to networked tools are libraries like AirBnB’s <a href="https://github.com/airbnb/react-sketchapp" target="_blank" rel="noopener">react-sketchapp</a>, which is capable of importing components from an application’s codebase into Sketch. This connection enables designers to use up-to-date components directly from AirBnB’s applications. But it’s a one-way connection; designers can’t push changes back to the components.</p>
<p>New applications like <a href="https://www.modulz.app/" target="_blank" rel="noopener">Modulz</a> promise to go a step further, empowering designers to work directly with application code in a visual medium. Modulz is a part of the “no-code” revolution, a drive to put more of the software creation process directly in the hands of designers, business analysts, product managers, and executives. Design APIs will be crucial to these tools. Instead of a developer updating the CSS, HTML, and JavaScript to reflect the latest design decisions, the design API serves as the connection between a designer (or, heaven help us, a stakeholder or client) and the finished product.</p>
<p>Such a direct connection opens up entirely new ways of building software. Today, design decisions like colors, font sizes, and spacing are ‘baked’ into an application’s code. A developer writes design specifications into the source code, which is then compiled and delivered to an end user. This causes problems when many developers are working on an application: different parts of the codebase are updated at different times, while different design specifications are baked in. The more features an app has, the harder it is to maintain a consistent user experience.</p>
<p>A design API would allow an application’s compiler to request the latest specifications every time it runs, ensuring the result is always up to date. Developers no longer have to bake design decisions into their code. No matter how large the code base, all the design decisions are maintained in a single place and distributed when needed.</p>
<p>Keeping design decisions separated from your application’s code base has another advantage: you can build logic into the API without adding to the complexity of the app itself. By logic, I mean programs that concern the design decisions themselves. These programs can run automatically or at a user’s request via an API endpoint. Accessibility tests could run every night, providing valuable usage guidelines to users who want to adhere to web standards like <a href="https://www.w3.org/TR/WCAG20/" target="_blank" rel="noopener">WCAG</a>. These tests could also run when a user adds a new color or updates an existing one, and the API could reject the request if the new color doesn’t meet accessibility standards.</p>
<h2 id="conclusion">Conclusion</h2>
<p>APIs are a powerful paradigm. Using the groundwork laid by the pioneers of networked programs, designers and developers can evolve their approach and unlock new ways of collaborating. And yet, design APIs don’t seem like a stretch of the imagination. An API-driven approach is the natural extension of the work currently being done on design systems, including tokens and standardization projects.</p>
<p>That’s why I’m so excited about design API-driven tools and frameworks: A fully-networked design system, powered by a design API, gives massive leverage to even the smallest teams. Using a design API, designers and developers can maintain larger and larger codebases, deployed over multiple apps and platforms, without sacrificing quality or consistency. Design concerns like accessibility could be automated and managed by dedicated systems; changes could be tested on the fly, in production, by a single designer.</p>
<p>As design systems evolve into fully-featured design APIs, the future of design is bright.</p>
